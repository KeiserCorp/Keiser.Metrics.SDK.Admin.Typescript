/* tslint:disable */
/* eslint-disable */
/**
 * metrics-sdk-admin
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 5.0.12
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CacheObjectResponse,
  FacilityLicenseListResponse,
  FacilityLicenseResponse,
  GlobalAccessControlCreationResponse,
  GlobalAccessControlListResponse,
  GlobalAccessControlResponse,
  GlobalAccessControlSecretResponse,
  ResqueDetailsResponse,
  StatListResponse,
  TaskFailedResponse,
  TaskQueueResponse,
  UserListResponse,
  UserResponse,
  WorkersResponse,
} from '../models';
import {
    CacheObjectResponseFromJSON,
    CacheObjectResponseToJSON,
    FacilityLicenseListResponseFromJSON,
    FacilityLicenseListResponseToJSON,
    FacilityLicenseResponseFromJSON,
    FacilityLicenseResponseToJSON,
    GlobalAccessControlCreationResponseFromJSON,
    GlobalAccessControlCreationResponseToJSON,
    GlobalAccessControlListResponseFromJSON,
    GlobalAccessControlListResponseToJSON,
    GlobalAccessControlResponseFromJSON,
    GlobalAccessControlResponseToJSON,
    GlobalAccessControlSecretResponseFromJSON,
    GlobalAccessControlSecretResponseToJSON,
    ResqueDetailsResponseFromJSON,
    ResqueDetailsResponseToJSON,
    StatListResponseFromJSON,
    StatListResponseToJSON,
    TaskFailedResponseFromJSON,
    TaskFailedResponseToJSON,
    TaskQueueResponseFromJSON,
    TaskQueueResponseToJSON,
    UserListResponseFromJSON,
    UserListResponseToJSON,
    UserResponseFromJSON,
    UserResponseToJSON,
    WorkersResponseFromJSON,
    WorkersResponseToJSON,
} from '../models';

export interface AdminLoginRequest {
    email: string;
    password: string;
    refreshable?: boolean;
    token?: string;
    apiVersion?: string;
}

export interface AuthExchangeFulfillmentRequest {
    exchangeToken: string;
    apiVersion?: string;
}

export interface FacilityLicenseCreateRequest {
    term: number;
    type: string;
    accountId?: string;
    email?: string;
    name?: string;
    apiVersion?: string;
}

export interface FacilityLicenseDeleteRequest {
    id: number;
    apiVersion?: string;
}

export interface FacilityLicenseListRequest {
    accountId?: string;
    ascending?: boolean;
    key?: string;
    limit?: number;
    name?: string;
    offset?: number;
    sort?: string;
    type?: string;
    apiVersion?: string;
}

export interface GlobalAccessControlCreateRequest {
    accessControlRights?: string;
    analyticRights?: string;
    exerciseRights?: string;
    facilityRights?: string;
    licenseRights?: string;
    mSeriesGuidedSessionRights?: string;
    resqueRights?: string;
    userId?: number;
    userRights?: string;
    apiVersion?: string;
}

export interface GlobalAccessControlDeleteRequest {
    userId: number;
    apiVersion?: string;
}

export interface GlobalAccessControlListRequest {
    ascending?: boolean;
    limit?: number;
    name?: string;
    offset?: number;
    sort?: string;
    apiVersion?: string;
}

export interface GlobalAccessControlRecreateSecretRequest {
    apiVersion?: string;
}

export interface GlobalAccessControlShowRequest {
    userId?: number;
    apiVersion?: string;
}

export interface GlobalAccessControlUpdateRequest {
    accessControlRights?: string;
    analyticRights?: string;
    exerciseRights?: string;
    facilityRights?: string;
    licenseRights?: string;
    mSeriesGuidedSessionRights?: string;
    resqueRights?: string;
    userId?: number;
    userRights?: string;
    apiVersion?: string;
}

export interface ResqueCacheCreateRequest {
    key: string;
    value: string;
    expireIn?: number;
    apiVersion?: string;
}

export interface ResqueCacheDeleteRequest {
    key: string;
    apiVersion?: string;
}

export interface ResqueCacheShowRequest {
    key: string;
    apiVersion?: string;
}

export interface ResqueCacheUpdateRequest {
    key: string;
    value: string;
    expireIn?: number;
    apiVersion?: string;
}

export interface ResqueDetailsRequest {
    apiVersion?: string;
}

export interface ResqueTaskDeleteAllFailedRequest {
    apiVersion?: string;
}

export interface ResqueTaskDeleteFailedRequest {
    failedTask: string;
    apiVersion?: string;
}

export interface ResqueTaskDeleteTaskRequest {
    args: string;
    queue: string;
    taskName: string;
    apiVersion?: string;
}

export interface ResqueTaskFailuresRequest {
    limit?: number;
    offset?: number;
    apiVersion?: string;
}

export interface ResqueTaskQueueRequest {
    queue: string;
    limit?: number;
    offset?: number;
    apiVersion?: string;
}

export interface ResqueTaskRetryAllFailedRequest {
    apiVersion?: string;
}

export interface ResqueTaskRetryFailedRequest {
    failedTask: string;
    apiVersion?: string;
}

export interface ResqueWorkerListRequest {
    apiVersion?: string;
}

export interface StatsListRequest {
    ascending?: boolean;
    from?: Date;
    limit?: number;
    offset?: number;
    sort?: string;
    to?: Date;
    apiVersion?: string;
}

export interface UserDeleteRequest {
    userId?: number;
    apiVersion?: string;
}

export interface UserListRequest {
    ascending?: boolean;
    email?: string;
    limit?: number;
    name?: string;
    offset?: number;
    sort?: string;
    apiVersion?: string;
}

export interface UserMergeRequest {
    fromUserId: number;
    toUserId: number;
    apiVersion?: string;
}

export interface UserShowRequest {
    userId?: number;
    apiVersion?: string;
}

/**
 * 
 */
export class MetricsAdminApi extends runtime.BaseAPI {

    /**
     * 1
     * Login admin user using email, password, and 2FA token
     */
    async adminLogin(requestParameters: AdminLoginRequest): Promise<UserResponse> {
        if (requestParameters.email === null || requestParameters.email === undefined) {            
            throw new runtime.RequiredError('email','Required parameter requestParameters.email was null or undefined when calling adminLogin.');
        }
        
        if (requestParameters.password === null || requestParameters.password === undefined) {            
            throw new runtime.RequiredError('password','Required parameter requestParameters.password was null or undefined when calling adminLogin.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.email !== undefined && requestParameters.email !== null) {
            queryParameters['email'] = requestParameters.email;
        }

        
        if (requestParameters.password !== undefined && requestParameters.password !== null) {
            queryParameters['password'] = requestParameters.password;
        }

        
        if (requestParameters.refreshable !== undefined && requestParameters.refreshable !== null) {
            queryParameters['refreshable'] = requestParameters.refreshable;
        }

        
        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            queryParameters['token'] = requestParameters.token;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/login`,
            action: 'admin:login',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 1
     * Exchanges an authorization token for access and refresh tokens
     */
    async authExchangeFulfillment(requestParameters: AuthExchangeFulfillmentRequest): Promise<UserResponse> {
        if (requestParameters.exchangeToken === null || requestParameters.exchangeToken === undefined) {            
            throw new runtime.RequiredError('exchangeToken','Required parameter requestParameters.exchangeToken was null or undefined when calling authExchangeFulfillment.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.exchangeToken !== undefined && requestParameters.exchangeToken !== null) {
            queryParameters['exchangeToken'] = requestParameters.exchangeToken;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/auth/exchange/fulfillment`,
            action: 'auth:exchangeFulfillment',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        });

        return response;
    }

    /**
     * 1
     * Create a facility license
     */
    async facilityLicenseCreate(requestParameters: FacilityLicenseCreateRequest): Promise<FacilityLicenseResponse> {
        if (requestParameters.term === null || requestParameters.term === undefined) {            
            throw new runtime.RequiredError('term','Required parameter requestParameters.term was null or undefined when calling facilityLicenseCreate.');
        }
        
        if (requestParameters.type === null || requestParameters.type === undefined) {            
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling facilityLicenseCreate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.accountId !== undefined && requestParameters.accountId !== null) {
            queryParameters['accountId'] = requestParameters.accountId;
        }

        
        if (requestParameters.email !== undefined && requestParameters.email !== null) {
            queryParameters['email'] = requestParameters.email;
        }

        
        if (requestParameters.name !== undefined && requestParameters.name !== null) {
            queryParameters['name'] = requestParameters.name;
        }

        
        if (requestParameters.term !== undefined && requestParameters.term !== null) {
            queryParameters['term'] = requestParameters.term;
        }

        
        if (requestParameters.type !== undefined && requestParameters.type !== null) {
            queryParameters['type'] = requestParameters.type;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/facility/license`,
            action: 'facilityLicense:create',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Delete a facility license
     */
    async facilityLicenseDelete(requestParameters: FacilityLicenseDeleteRequest): Promise<void> {
        if (requestParameters.id === null || requestParameters.id === undefined) {            
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling facilityLicenseDelete.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            pathParameters['id'] = requestParameters.id;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/facility/license/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            action: 'facilityLicense:delete',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * List facility licenses
     */
    async facilityLicenseList(requestParameters: FacilityLicenseListRequest): Promise<FacilityLicenseListResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.accountId !== undefined && requestParameters.accountId !== null) {
            queryParameters['accountId'] = requestParameters.accountId;
        }

        
        if (requestParameters.ascending !== undefined && requestParameters.ascending !== null) {
            queryParameters['ascending'] = requestParameters.ascending;
        }

        
        if (requestParameters.key !== undefined && requestParameters.key !== null) {
            queryParameters['key'] = requestParameters.key;
        }

        
        if (requestParameters.limit !== undefined && requestParameters.limit !== null) {
            queryParameters['limit'] = requestParameters.limit;
        }

        
        if (requestParameters.name !== undefined && requestParameters.name !== null) {
            queryParameters['name'] = requestParameters.name;
        }

        
        if (requestParameters.offset !== undefined && requestParameters.offset !== null) {
            queryParameters['offset'] = requestParameters.offset;
        }

        
        if (requestParameters.sort !== undefined && requestParameters.sort !== null) {
            queryParameters['sort'] = requestParameters.sort;
        }

        
        if (requestParameters.type !== undefined && requestParameters.type !== null) {
            queryParameters['type'] = requestParameters.type;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/facility/license/list`,
            action: 'facilityLicense:list',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Create a user\'s global access control rights
     */
    async globalAccessControlCreate(requestParameters: GlobalAccessControlCreateRequest): Promise<GlobalAccessControlCreationResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.accessControlRights !== undefined && requestParameters.accessControlRights !== null) {
            queryParameters['accessControlRights'] = requestParameters.accessControlRights;
        }

        
        if (requestParameters.analyticRights !== undefined && requestParameters.analyticRights !== null) {
            queryParameters['analyticRights'] = requestParameters.analyticRights;
        }

        
        if (requestParameters.exerciseRights !== undefined && requestParameters.exerciseRights !== null) {
            queryParameters['exerciseRights'] = requestParameters.exerciseRights;
        }

        
        if (requestParameters.facilityRights !== undefined && requestParameters.facilityRights !== null) {
            queryParameters['facilityRights'] = requestParameters.facilityRights;
        }

        
        if (requestParameters.licenseRights !== undefined && requestParameters.licenseRights !== null) {
            queryParameters['licenseRights'] = requestParameters.licenseRights;
        }

        
        if (requestParameters.mSeriesGuidedSessionRights !== undefined && requestParameters.mSeriesGuidedSessionRights !== null) {
            queryParameters['mSeriesGuidedSessionRights'] = requestParameters.mSeriesGuidedSessionRights;
        }

        
        if (requestParameters.resqueRights !== undefined && requestParameters.resqueRights !== null) {
            queryParameters['resqueRights'] = requestParameters.resqueRights;
        }

        
        if (requestParameters.userId !== undefined && requestParameters.userId !== null) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.userRights !== undefined && requestParameters.userRights !== null) {
            queryParameters['userRights'] = requestParameters.userRights;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/global-access-control`,
            action: 'globalAccessControl:create',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Delete a user\'s global access control
     */
    async globalAccessControlDelete(requestParameters: GlobalAccessControlDeleteRequest): Promise<void> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {            
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling globalAccessControlDelete.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.userId !== undefined && requestParameters.userId !== null) {
            pathParameters['userId'] = requestParameters.userId;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/global-access-control/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            action: 'globalAccessControl:delete',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * List global access control for users
     */
    async globalAccessControlList(requestParameters: GlobalAccessControlListRequest): Promise<GlobalAccessControlListResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.ascending !== undefined && requestParameters.ascending !== null) {
            queryParameters['ascending'] = requestParameters.ascending;
        }

        
        if (requestParameters.limit !== undefined && requestParameters.limit !== null) {
            queryParameters['limit'] = requestParameters.limit;
        }

        
        if (requestParameters.name !== undefined && requestParameters.name !== null) {
            queryParameters['name'] = requestParameters.name;
        }

        
        if (requestParameters.offset !== undefined && requestParameters.offset !== null) {
            queryParameters['offset'] = requestParameters.offset;
        }

        
        if (requestParameters.sort !== undefined && requestParameters.sort !== null) {
            queryParameters['sort'] = requestParameters.sort;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/global-access-control/list`,
            action: 'globalAccessControl:list',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Recreate a user\'s authenticator secret
     */
    async globalAccessControlRecreateSecret(requestParameters: GlobalAccessControlRecreateSecretRequest): Promise<GlobalAccessControlSecretResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/global-access-control/recreate-secret`,
            action: 'globalAccessControl:recreateSecret',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Show a global access control
     */
    async globalAccessControlShow(requestParameters: GlobalAccessControlShowRequest): Promise<GlobalAccessControlResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.userId !== undefined && requestParameters.userId !== null) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/global-access-control`,
            action: 'globalAccessControl:show',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Update a user global access control rights
     */
    async globalAccessControlUpdate(requestParameters: GlobalAccessControlUpdateRequest): Promise<GlobalAccessControlResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.accessControlRights !== undefined && requestParameters.accessControlRights !== null) {
            queryParameters['accessControlRights'] = requestParameters.accessControlRights;
        }

        
        if (requestParameters.analyticRights !== undefined && requestParameters.analyticRights !== null) {
            queryParameters['analyticRights'] = requestParameters.analyticRights;
        }

        
        if (requestParameters.exerciseRights !== undefined && requestParameters.exerciseRights !== null) {
            queryParameters['exerciseRights'] = requestParameters.exerciseRights;
        }

        
        if (requestParameters.facilityRights !== undefined && requestParameters.facilityRights !== null) {
            queryParameters['facilityRights'] = requestParameters.facilityRights;
        }

        
        if (requestParameters.licenseRights !== undefined && requestParameters.licenseRights !== null) {
            queryParameters['licenseRights'] = requestParameters.licenseRights;
        }

        
        if (requestParameters.mSeriesGuidedSessionRights !== undefined && requestParameters.mSeriesGuidedSessionRights !== null) {
            queryParameters['mSeriesGuidedSessionRights'] = requestParameters.mSeriesGuidedSessionRights;
        }

        
        if (requestParameters.resqueRights !== undefined && requestParameters.resqueRights !== null) {
            queryParameters['resqueRights'] = requestParameters.resqueRights;
        }

        
        if (requestParameters.userId !== undefined && requestParameters.userId !== null) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.userRights !== undefined && requestParameters.userRights !== null) {
            queryParameters['userRights'] = requestParameters.userRights;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/global-access-control`,
            action: 'globalAccessControl:update',
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Create cached object
     */
    async resqueCacheCreate(requestParameters: ResqueCacheCreateRequest): Promise<CacheObjectResponse> {
        if (requestParameters.key === null || requestParameters.key === undefined) {            
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling resqueCacheCreate.');
        }
        
        if (requestParameters.value === null || requestParameters.value === undefined) {            
            throw new runtime.RequiredError('value','Required parameter requestParameters.value was null or undefined when calling resqueCacheCreate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.expireIn !== undefined && requestParameters.expireIn !== null) {
            queryParameters['expireIn'] = requestParameters.expireIn;
        }

        
        if (requestParameters.key !== undefined && requestParameters.key !== null) {
            queryParameters['key'] = requestParameters.key;
        }

        
        if (requestParameters.value !== undefined && requestParameters.value !== null) {
            queryParameters['value'] = requestParameters.value;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/cache`,
            action: 'resque:cache:create',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Delete cached object
     */
    async resqueCacheDelete(requestParameters: ResqueCacheDeleteRequest): Promise<void> {
        if (requestParameters.key === null || requestParameters.key === undefined) {            
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling resqueCacheDelete.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.key !== undefined && requestParameters.key !== null) {
            pathParameters['key'] = requestParameters.key;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/cache/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            action: 'resque:cache:delete',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * Show cache object
     */
    async resqueCacheShow(requestParameters: ResqueCacheShowRequest): Promise<CacheObjectResponse> {
        if (requestParameters.key === null || requestParameters.key === undefined) {            
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling resqueCacheShow.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.key !== undefined && requestParameters.key !== null) {
            queryParameters['key'] = requestParameters.key;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/cache`,
            action: 'resque:cache:show',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Update cached object
     */
    async resqueCacheUpdate(requestParameters: ResqueCacheUpdateRequest): Promise<CacheObjectResponse> {
        if (requestParameters.key === null || requestParameters.key === undefined) {            
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling resqueCacheUpdate.');
        }
        
        if (requestParameters.value === null || requestParameters.value === undefined) {            
            throw new runtime.RequiredError('value','Required parameter requestParameters.value was null or undefined when calling resqueCacheUpdate.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.expireIn !== undefined && requestParameters.expireIn !== null) {
            queryParameters['expireIn'] = requestParameters.expireIn;
        }

        
        if (requestParameters.value !== undefined && requestParameters.value !== null) {
            queryParameters['value'] = requestParameters.value;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }
        if (requestParameters.key !== undefined && requestParameters.key !== null) {
            pathParameters['key'] = requestParameters.key;
        }



        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/cache/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            action: 'resque:cache:update',
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Show wholistic details about resque system
     */
    async resqueDetails(requestParameters: ResqueDetailsRequest): Promise<ResqueDetailsResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/details`,
            action: 'resque:details',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Delete all failed task
     */
    async resqueTaskDeleteAllFailed(requestParameters: ResqueTaskDeleteAllFailedRequest): Promise<void> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/task/delete-all-failed`,
            action: 'resque:task:deleteAllFailed',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * Delete a failed task
     */
    async resqueTaskDeleteFailed(requestParameters: ResqueTaskDeleteFailedRequest): Promise<void> {
        if (requestParameters.failedTask === null || requestParameters.failedTask === undefined) {            
            throw new runtime.RequiredError('failedTask','Required parameter requestParameters.failedTask was null or undefined when calling resqueTaskDeleteFailed.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.failedTask !== undefined && requestParameters.failedTask !== null) {
            queryParameters['failedTask'] = requestParameters.failedTask;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/task/delete-failed`,
            action: 'resque:task:deleteFailed',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * Delete a task from the queue
     */
    async resqueTaskDeleteTask(requestParameters: ResqueTaskDeleteTaskRequest): Promise<void> {
        if (requestParameters.args === null || requestParameters.args === undefined) {            
            throw new runtime.RequiredError('args','Required parameter requestParameters.args was null or undefined when calling resqueTaskDeleteTask.');
        }
        
        if (requestParameters.queue === null || requestParameters.queue === undefined) {            
            throw new runtime.RequiredError('queue','Required parameter requestParameters.queue was null or undefined when calling resqueTaskDeleteTask.');
        }
        
        if (requestParameters.taskName === null || requestParameters.taskName === undefined) {            
            throw new runtime.RequiredError('taskName','Required parameter requestParameters.taskName was null or undefined when calling resqueTaskDeleteTask.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.args !== undefined && requestParameters.args !== null) {
            queryParameters['args'] = requestParameters.args;
        }

        
        if (requestParameters.queue !== undefined && requestParameters.queue !== null) {
            queryParameters['queue'] = requestParameters.queue;
        }

        
        if (requestParameters.taskName !== undefined && requestParameters.taskName !== null) {
            queryParameters['taskName'] = requestParameters.taskName;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/task/delete-task`,
            action: 'resque:task:deleteTask',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * Lists failed tasks
     */
    async resqueTaskFailures(requestParameters: ResqueTaskFailuresRequest): Promise<TaskFailedResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.limit !== undefined && requestParameters.limit !== null) {
            queryParameters['limit'] = requestParameters.limit;
        }

        
        if (requestParameters.offset !== undefined && requestParameters.offset !== null) {
            queryParameters['offset'] = requestParameters.offset;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/task/failures`,
            action: 'resque:task:failures',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Lists enqueued tasks
     */
    async resqueTaskQueue(requestParameters: ResqueTaskQueueRequest): Promise<TaskQueueResponse> {
        if (requestParameters.queue === null || requestParameters.queue === undefined) {            
            throw new runtime.RequiredError('queue','Required parameter requestParameters.queue was null or undefined when calling resqueTaskQueue.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.limit !== undefined && requestParameters.limit !== null) {
            queryParameters['limit'] = requestParameters.limit;
        }

        
        if (requestParameters.offset !== undefined && requestParameters.offset !== null) {
            queryParameters['offset'] = requestParameters.offset;
        }

        
        if (requestParameters.queue !== undefined && requestParameters.queue !== null) {
            queryParameters['queue'] = requestParameters.queue;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/task/queue`,
            action: 'resque:task:queue',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Remove and retry all failed task
     */
    async resqueTaskRetryAllFailed(requestParameters: ResqueTaskRetryAllFailedRequest): Promise<void> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/task/retry-all-failed`,
            action: 'resque:task:retryAllFailed',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * Remove and retry a failed task
     */
    async resqueTaskRetryFailed(requestParameters: ResqueTaskRetryFailedRequest): Promise<void> {
        if (requestParameters.failedTask === null || requestParameters.failedTask === undefined) {            
            throw new runtime.RequiredError('failedTask','Required parameter requestParameters.failedTask was null or undefined when calling resqueTaskRetryFailed.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.failedTask !== undefined && requestParameters.failedTask !== null) {
            queryParameters['failedTask'] = requestParameters.failedTask;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/task/retry-failed`,
            action: 'resque:task:retryFailed',
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * List resque workers
     */
    async resqueWorkerList(requestParameters: ResqueWorkerListRequest): Promise<WorkersResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/resque/worker`,
            action: 'resque:worker:list',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Shows stats queries
     */
    async statsList(requestParameters: StatsListRequest): Promise<StatListResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.ascending !== undefined && requestParameters.ascending !== null) {
            queryParameters['ascending'] = requestParameters.ascending;
        }

        
        if (requestParameters.from !== undefined && requestParameters.from !== null) {
            queryParameters['from'] = (requestParameters.from as any).toISOString();
        }

        
        if (requestParameters.limit !== undefined && requestParameters.limit !== null) {
            queryParameters['limit'] = requestParameters.limit;
        }

        
        if (requestParameters.offset !== undefined && requestParameters.offset !== null) {
            queryParameters['offset'] = requestParameters.offset;
        }

        
        if (requestParameters.sort !== undefined && requestParameters.sort !== null) {
            queryParameters['sort'] = requestParameters.sort;
        }

        
        if (requestParameters.to !== undefined && requestParameters.to !== null) {
            queryParameters['to'] = (requestParameters.to as any).toISOString();
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/stats`,
            action: 'stats:list',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Delete a user
     */
    async userDelete(requestParameters: UserDeleteRequest): Promise<void> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.userId !== undefined && requestParameters.userId !== null) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user`,
            action: 'user:delete',
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

    }

    /**
     * 1
     * List users
     */
    async userList(requestParameters: UserListRequest): Promise<UserListResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.ascending !== undefined && requestParameters.ascending !== null) {
            queryParameters['ascending'] = requestParameters.ascending;
        }

        
        if (requestParameters.email !== undefined && requestParameters.email !== null) {
            queryParameters['email'] = requestParameters.email;
        }

        
        if (requestParameters.limit !== undefined && requestParameters.limit !== null) {
            queryParameters['limit'] = requestParameters.limit;
        }

        
        if (requestParameters.name !== undefined && requestParameters.name !== null) {
            queryParameters['name'] = requestParameters.name;
        }

        
        if (requestParameters.offset !== undefined && requestParameters.offset !== null) {
            queryParameters['offset'] = requestParameters.offset;
        }

        
        if (requestParameters.sort !== undefined && requestParameters.sort !== null) {
            queryParameters['sort'] = requestParameters.sort;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user/list`,
            action: 'user:list',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Merge two user together
     */
    async userMerge(requestParameters: UserMergeRequest): Promise<UserResponse> {
        if (requestParameters.fromUserId === null || requestParameters.fromUserId === undefined) {            
            throw new runtime.RequiredError('fromUserId','Required parameter requestParameters.fromUserId was null or undefined when calling userMerge.');
        }
        
        if (requestParameters.toUserId === null || requestParameters.toUserId === undefined) {            
            throw new runtime.RequiredError('toUserId','Required parameter requestParameters.toUserId was null or undefined when calling userMerge.');
        }
        
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.fromUserId !== undefined && requestParameters.fromUserId !== null) {
            queryParameters['fromUserId'] = requestParameters.fromUserId;
        }

        
        if (requestParameters.toUserId !== undefined && requestParameters.toUserId !== null) {
            queryParameters['toUserId'] = requestParameters.toUserId;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user/merge`,
            action: 'user:merge',
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

    /**
     * 1
     * Show a user
     */
    async userShow(requestParameters: UserShowRequest): Promise<UserResponse> {
        const queryParameters: any = {};
        const pathParameters: any = {};

        
        if (requestParameters.userId !== undefined && requestParameters.userId !== null) {
            queryParameters['userId'] = requestParameters.userId;
        }

        
        if (requestParameters.apiVersion !== undefined && requestParameters.apiVersion !== null) {
            queryParameters['apiVersion'] = requestParameters.apiVersion;
        }


        if (requestParameters.apiVersion === undefined) {
            queryParameters['apiVersion'] = 1;
        }


        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/user`,
            action: 'user:show',
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
            pathParams: pathParameters,
        },
        true
        );

        return response;
    }

}
